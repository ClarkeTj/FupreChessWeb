<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Matches | Fupre Chess Club</title>

  
  <!-- ICO for classic support -->
<link rel="icon" type="image/x-icon" href="fupreChess_favicon.ico">

<!-- PNG for modern browsers -->
<link rel="icon" type="image/png" sizes="32x32" href="fupreChess_favicon.png">


  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&family=Poppins:wght@400;500&display=swap" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500&family=Montserrat:wght@600&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css" />
  <script defer src="script.js"></script>
</head>
<body>
  <header class="navbar">
    <div class="logo-container">
      <img src="imgs/fupreChesslogo.png" alt="Fupre Chess Club Logo" class="logo" />
      <span class="site-title">Fupre Chess Club</span>
    </div>
    <nav class="nav-links" id="nav-links">
      <a href="index.html">Home</a>
      <a href="ratings.html">Ratings</a>
      <a href="tournaments.html">Tournaments</a>
      <a href="matches.html">Matches</a>
      <a href="rulebook.html">Rulebook</a>
      <a href="contact.html">Contact</a>
    </nav>
    <div class="nav-actions">
      <button id="dark-toggle" class="dark-toggle">🌓</button>
      <button class="hamburger" id="hamburger">&#9776;</button>
    </div>
  </header>


  <main class="main-content">

    <section class="matches-section">
  <h2>Match History</h2>
  <p>Track recent games and results.</p>


<div class="filters">
  <div class="filter-group" data-icon="🔍">
    <select id="playerFilter">
      <option value="">Filter by Player</option>
    </select>
    <span id="playerBadge" class="player-badge"></span>
  </div>

  <div class="filter-group" data-icon="📅">
    <input type="date" id="startDate" placeholder="Start Date">
    <small class="hint-text">Start Date</small>
  </div>

  <div class="filter-group" data-icon="📅">
    <input type="date" id="endDate" placeholder="End Date">
    <small class="hint-text">End Date</small>
  </div>

  <div class="filter-group" data-icon="↕">
    <select id="sortFilter">
      <option value="recent">Sort: Most Recent</option>
      <option value="oldest">Sort: Oldest</option>
      <option value="winner">Sort: By Winner</option>
    </select>
  </div>
</div>


  <!-- Matches Container -->
  <div class="matches-wrapper table-mode">
    <table id="matchesTable" class="table-view">
      <thead>
        <tr>
          <th>Player A</th>
          <th>Player B</th>
          <th>Result</th>
          <th>Date</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</section>


<!-- Modal -->
<div id="matchModal" class="modal">
  <div class="modal-content">
    <span class="close-btn">&times;</span>
    <h3 id="modalTitle"></h3>
    <div id="modalDetails"></div>
    <div id="headToHead"></div>
  </div>
</div>

<section class="leaderboard-section">
  <h2>🏆 Top Performers</h2>
  <p>Players with the most wins</p>
  <ul id="leaderboardList" class="leaderboard-list"></ul>
</section>


  </main>


<script>
/* =========================
   Matches Page 
========================= */
(() => {
  'use strict';

  // ------- tiny scoped helpers -------
  const $ = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => [...root.querySelectorAll(sel)];
  const on = (el, evt, fn) => el && el.addEventListener(evt, fn);

  const state = {
    matches: []
  };

  // ---------- boot ----------
  document.addEventListener('DOMContentLoaded', async () => {
    await loadMatches();

    // filters
    on($("#playerFilter"), "change", render);
    on($("#startDate"), "change", render);
    on($("#endDate"), "change", render);
    on($("#sortFilter"), "change", render);

    // modal close (bind once)
    const modal = $("#matchModal");
    const closeBtn = $(".close-btn");
    on(closeBtn, "click", () => modal.style.display = "none");
    on(window, "click", (e) => { if (e.target === modal) modal.style.display = "none"; });

    // first render
    render();
  });

  // ---------- data ----------
  async function loadMatches() {
    try {
      const res = await fetch("matches.json?nocache=" + Date.now());
      const data = await res.json();
      state.matches = data.matches || [];
      buildPlayerFilter();
    } catch (e) {
      console.error("Failed to load matches.json", e);
      state.matches = [];
    }
  }

  function buildPlayerFilter() {
    const sel = $("#playerFilter");
    if (!sel) return;
    const players = new Set();
    state.matches.forEach(m => { players.add(m.playerA); players.add(m.playerB); });
    sel.innerHTML = `<option value="">Filter by Player</option>` +
      [...players].sort((a,b)=>a.localeCompare(b))
                  .map(p=>`<option value="${p}">${p}</option>`).join("");
  }

  // ---------- filters/sort ----------
  function getFilters() {
    return {
      player: $("#playerFilter")?.value?.trim() || "",
      start:  $("#startDate")?.value || "",
      end:    $("#endDate")?.value || "",
      sort:   $("#sortFilter")?.value || "recent",
    };
  }

  function withinRange(dateStr, start, end) {
    if (!start && !end) return true;
    const d = new Date(dateStr);
    if (start && d < new Date(start)) return false;
    if (end   && d > new Date(end))   return false;
    return true;
  }

  function getWinner(m) {
    const [a,b] = (m.result || "").split("-").map(v=>parseFloat(v));
    if (isNaN(a) || isNaN(b)) return "Draw";
    if (a > b) return m.playerA;
    if (b > a) return m.playerB;
    return "Draw";
  }

  function filteredSorted() {
    const { player, start, end, sort } = getFilters();

    const list = state.matches.filter(m => {
      const plays = !player || m.playerA === player || m.playerB === player;
      return plays && withinRange(m.date, start, end);
    });

    switch (sort) {
      case "recent": list.sort((a,b)=> new Date(b.date) - new Date(a.date)); break;
      case "oldest": list.sort((a,b)=> new Date(a.date) - new Date(b.date)); break;
      case "winner": list.sort((a,b)=> getWinner(a).localeCompare(getWinner(b))); break;
    }
    return list;
  }

  // Smart handling for Start/End Date
  const startInput = document.getElementById("startDate");
  const endInput = document.getElementById("endDate");

  if (startInput && endInput) {
    endInput.disabled = true;
    startInput.addEventListener("change", () => {
      if (startInput.value) {
        endInput.disabled = false;
        endInput.min = startInput.value;
        if (endInput.value && endInput.value < startInput.value) {
          endInput.value = "";
        }
      } else {
        endInput.value = "";
        endInput.disabled = true;
        endInput.removeAttribute("min");
      }
    });
  }

  // ---------- render ----------
  function render() {
    updatePlayerBadge();

    const wrapper = $(".matches-wrapper");
    if (!wrapper) return;

    wrapper.innerHTML = "";

    const grid = document.createElement("div");
    grid.className = "matches-grid";
    wrapper.appendChild(grid);

    const data = filteredSorted();

    data.forEach((m,i) => {
      const w = getWinner(m);
      const winA = w === m.playerA, winB = w === m.playerB, draw = (w === "Draw");
      const aTone = winA ? "win" : draw ? "draw" : "loss";
      const bTone = winB ? "win" : draw ? "draw" : "loss";
      const icon = draw ? "🤝" : "👑";

      const card = document.createElement("article");
      card.className = "match-card hidden";
      card.dataset.index = String(i);
      card.innerHTML = `
        <div class="mc-row">
          <span class="player ${aTone}">${m.playerA}${winA ? " "+icon : ""}</span>
          <span class="vs">vs</span>
          <span class="player ${bTone}">${m.playerB}${winB ? " "+icon : ""}</span>
        </div>
        <div class="mc-row">
          <span class="result"><strong>${m.result}</strong></span>
          <span class="date">${m.date}</span>
        </div>
        <div class="mc-meta"><em>${m.event || "Friendly"} • ${m.timeControl || "—"}</em></div>
      `;
      grid.appendChild(card);
    });

    applyCollapsible();
    attachOpenModalHandlers();
    buildLeaderboard();
  }

  /* =====================
     Leaderboard Handling
  ===================== */
  function buildLeaderboard(){
    const winCount = {};
    state.matches.forEach(m => {
      const winner = getWinner(m);
      if (winner !== "Draw") {
        winCount[winner] = (winCount[winner] || 0) + 1;
      }
    });

    const sorted = Object.entries(winCount)
      .sort((a,b) => b[1] - a[1])
      .slice(0,5);

    const list = document.getElementById("leaderboardList");
    if (!list) return;
    list.innerHTML = "";

    sorted.forEach(([player, wins], idx) => {
      const li = document.createElement("li");
      li.innerHTML = `
        <span class="player-name">${idx===0 ? "👑 " : ""}${player}</span>
        <span class="wins">${wins} Wins</span>
      `;
      list.appendChild(li);
    });
  }

  // ---------- collapsible w/ glow ----------
  function applyCollapsible() {
    $$(".collapse-btn").forEach(b => b.remove());

    const items = $$(".match-card");
    if (!items.length) return;

    const maxRows = window.innerWidth <= 480 ? 4 : 8;

    items.forEach(el => { el.classList.remove("show","glow"); el.style.display = "block"; });
    items.forEach(el => el.classList.add("hidden"));

    items.slice(0, maxRows).forEach((el,i) => {
      setTimeout(() => {
        el.classList.remove("hidden");
        el.classList.add("show");
        void el.offsetWidth;
        el.classList.add("glow");
      }, i * 80);
    });

    if (items.length <= maxRows) return;

    items.slice(maxRows).forEach(el => { el.classList.add("hidden"); el.style.display = "none"; });

    const host = $(".matches-wrapper");
    const btn = document.createElement("button");
    btn.className = "collapse-btn";
    btn.innerHTML = `Show More <span class="chev">▼</span>`;
    host.insertAdjacentElement("afterend", btn);

    let expanded = false;
    on(btn, "click", () => {
      expanded = !expanded;
      items.slice(maxRows).forEach((el,i) => {
        if (expanded) {
          el.style.display = "block";
          void el.offsetWidth;
          setTimeout(() => {
            el.classList.remove("hidden");
            el.classList.add("show");
            void el.offsetWidth;
            el.classList.add("glow");
          }, i * 90);
        } else {
          setTimeout(() => {
            el.classList.remove("show");
            setTimeout(() => {
              el.classList.add("hidden");
              el.style.display = "none";
            }, 260);
          }, i * 80);
        }
      });
      btn.innerHTML = expanded ? `Show Less <span class="chev">▲</span>`
                               : `Show More <span class="chev">▼</span>`;
      btn.classList.toggle("expanded", expanded);
    });
  }

  // ---------- badge ----------
  function updatePlayerBadge() {
    const badge = $("#playerBadge");
    if (!badge) return;

    const { player, start, end } = getFilters();
    if (!player) { badge.textContent = ""; return; }

    const pool = state.matches.filter(m => withinRange(m.date, start, end));
    let w=0,l=0,d=0;
    pool.forEach(m=>{
      if (m.playerA !== player && m.playerB !== player) return;
      const winner = getWinner(m);
      if (winner === "Draw") d++;
      else if (winner === player) w++;
      else l++;
    });
    badge.textContent = `${player}: ${w}W - ${l}L - ${d}D`;
  }

  // ---------- modal ----------
  function attachOpenModalHandlers(){
    const cards = $$(".match-card");
    cards.forEach(el => {
      on(el, "click", () => {
        const idx = Number(el.dataset.index || 0);
        const m = filteredSorted()[idx];
        openModal(m);
      });
    });
  }

  function openModal(m) {
    const modal = $("#matchModal");
    const modalTitle = $("#modalTitle");
    const modalDetails = $("#modalDetails");
    const headToHead = $("#headToHead");
    if (!modal || !m) return;

    modal.style.display = "flex";
    modalTitle.textContent = `${m.playerA} vs ${m.playerB}`;

    modalDetails.innerHTML = `
      <p><strong>Result:</strong> ${m.result}</p>
      <p><strong>Date:</strong> ${m.date}</p>
      <p><strong>Event:</strong> ${m.event || "Friendly"}</p>
      <p><strong>Time Control:</strong> ${m.timeControl || "—"}</p>
    `;

    const h2h = state.matches.filter(x =>
      (x.playerA === m.playerA && x.playerB === m.playerB) ||
      (x.playerA === m.playerB && x.playerB === m.playerA)
    );

    let aW=0,bW=0,dr=0;
    h2h.forEach(x => {
      const w = getWinner(x);
      if (w === m.playerA) aW++;
      else if (w === m.playerB) bW++;
      else dr++;
    });

    headToHead.innerHTML = `
      <h4>Head-to-Head</h4>
      <p>${m.playerA}: ${aW} wins</p>
      <p>${m.playerB}: ${bW} wins</p>
      <p>Draws: ${dr}</p>
      <small>Total: ${h2h.length}</small>
    `;
  }
})();
</script>


</body>
</html>
